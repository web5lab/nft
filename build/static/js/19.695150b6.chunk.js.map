{"version":3,"sources":["../../src/baseProvider.ts","../../src/utils.ts","../../src/PrivateKeyWallet.ts","../../src/rpc/JrpcClient.ts","../../src/rpc/solanaRpcMiddlewares.ts","../../src/providers/injectedProviders/injectedProviderProxy.ts","../../src/providers/injectedProviders/phantom/providerHandlers.ts","../../src/providers/injectedProviders/phantom/phantomInjectedProvider.ts","../../src/providers/injectedProviders/torus/providerHandlers.ts","../../src/providers/injectedProviders/torus/torusInjectedProvider.ts","../../src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts","../../src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts","../../src/solanaWallet.ts"],"names":["constructor","state","config","WalletInitializationError","chainId","chainConfig","networks","provider","addChain","ethErrors","getChainConfig","getProviderEngineProxy","updateProviderEngineProxy","createEventEmitterProxy","getCreateRandomId","PrivateKeyWallet","requestAccounts","method","params","accounts","signAndSendTransaction","signedTx","bs58","sig","signature","sendTransaction","signTransaction","privateKey","keyPair","Keypair","Buffer","transaction","signAllTransactions","signMessage","nacl","request","result","req","res","end","next","mergeMiddleware","createChainIdMiddleware","createProviderConfigMiddleware","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","createConfigMiddleware","getAccounts","createAsyncMiddleware","response","handler","getPrivateKey","createRequestAccountsMiddleware","createGetAccountsMiddleware","createGenericJRPCMiddleware","getPhantomHandlers","injectedProvider","providerHandlers","message","txn","Transaction","txRes","txns","msg","decodedMsg","chainNamespace","CHAIN_NAMESPACES","SOLANA","switchChain","Promise","setupProvider","solanaMiddleware","createSolanaMiddleware","configMiddleware","injectedProviderProxy","createInjectedProviderProxyMiddleware","engine","providerFromEngine","lookupNetwork","getTorusHandlers","data","buf","sendTx","messages","handleInjectedProviderUpdate","code","connectedChainId","connectedHexChainId","isHexStrict","parseInt","setupEngine","transactionGenerator","serializedTx","decodedTx","keyPairGenerator","signedMsg","_providerEngineProxy","signedTransactions","enable","getProviderHandlers","privKey","createJsonRpcClient","updateAccount","health","getChainSwitchMiddleware","chainSwitchHandlers","addNewChainConfig","nativeCurrency","rpcUrls","ticker","tickerName","displayName","blockExplorer","switchSolanaChain","createChainSwitchMiddleware","getAccountMiddleware","accountHandlers","updatePrivatekey","createAccountMiddleware","SolanaPrivateKeyProvider","providerFactory","SolanaWallet","requireAllSignatures","signedTransaction"],"mappings":"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","file":"static/js/19.695150b6.chunk.js","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { BaseController, createEventEmitterProxy } from '@toruslabs/base-controllers';\nimport { WalletInitializationError } from '@web3auth/base';\nimport { ethErrors } from 'eth-rpc-errors';\nimport getCreateRandomId from 'json-rpc-random-id';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseProvider extends BaseController {\n  // should be Assigned in setupProvider\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config,\n      state\n    });\n\n    _defineProperty(this, \"_providerEngineProxy\", null);\n\n    if (!config.chainConfig) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainConfig\");\n    if (!config.chainConfig.chainId) throw WalletInitializationError.invalidProviderConfigError(\"Please provide chainId inside chainConfig\");\n    if (!config.chainConfig.rpcTarget) throw WalletInitializationError.invalidProviderConfigError(\"Please provide rpcTarget inside chainConfig\");\n    this.defaultState = {\n      chainId: \"loading\"\n    };\n    this.defaultConfig = {\n      chainConfig: config.chainConfig,\n      networks: {\n        [config.chainConfig.chainId]: config.chainConfig\n      }\n    };\n    super.initialize();\n  }\n\n  get provider() {\n    return this._providerEngineProxy;\n  }\n\n  set provider(_) {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  addChain(chainConfig) {\n    if (!chainConfig.chainId) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    if (!chainConfig.rpcTarget) throw ethErrors.rpc.invalidParams(\"chainId is required\");\n    this.configure({\n      networks: _objectSpread(_objectSpread({}, this.config.networks), {}, {\n        [chainConfig.chainId]: chainConfig\n      })\n    });\n  }\n\n  getChainConfig(chainId) {\n    var _this$config$networks;\n\n    const chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];\n    if (!chainConfig) throw ethErrors.rpc.invalidRequest(\"Chain \".concat(chainId, \" is not supported, please add chainConfig for it\"));\n    return chainConfig;\n  }\n\n  getProviderEngineProxy() {\n    return this._providerEngineProxy;\n  }\n\n  updateProviderEngineProxy(providerEngineProxy) {\n    if (this._providerEngineProxy) {\n      this._providerEngineProxy.setTarget(providerEngineProxy);\n    } else {\n      this._providerEngineProxy = createEventEmitterProxy(providerEngineProxy);\n    }\n  }\n\n}\n\nconst createRandomId = getCreateRandomId();\n\nexport { BaseProvider, createRandomId };\n//# sourceMappingURL=baseProvider.esm.js.map\n",null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { Keypair, Transaction } from '@solana/web3.js';\nimport nacl from '@toruslabs/tweetnacl-js';\nimport bs58 from 'bs58';\nimport { createFetchMiddleware, providerFromEngine } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\n\nclass PrivateKeyWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const signedTx = await this.signTransaction(transaction);\n    const sig = await this.provider.request({\n      method: \"sendTransaction\",\n      params: [bs58.encode(signedTx.serialize())]\n    });\n    return {\n      signature: sig\n    };\n  }\n\n  async sendTransaction(transaction) {\n    const signedTx = await this.signTransaction(transaction);\n    const sig = await this.provider.request({\n      method: \"sendTransaction\",\n      params: [bs58.encode(signedTx.serialize())]\n    });\n    return {\n      signature: sig\n    };\n  }\n\n  async signTransaction(transaction) {\n    const privateKey = await this.provider.request({\n      method: \"solanaPrivateKey\"\n    });\n    const keyPair = Keypair.fromSecretKey(Buffer.from(privateKey, \"hex\"));\n    transaction.partialSign(keyPair);\n    return transaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const privateKey = await this.provider.request({\n      method: \"solanaPrivateKey\"\n    });\n    const keyPair = Keypair.fromSecretKey(Buffer.from(privateKey, \"hex\"));\n    return transactions.map(transaction => {\n      transaction.partialSign(keyPair);\n      return transaction;\n    });\n  }\n\n  async signMessage(data) {\n    const privateKey = await this.provider.request({\n      method: \"solanaPrivateKey\"\n    });\n    const keyPair = Keypair.fromSecretKey(Buffer.from(privateKey, \"hex\"));\n    const signature = nacl.sign.detached(data, keyPair.secretKey);\n    return signature;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createConfigMiddleware(providerConfig) {\n  const {\n    chainId\n  } = providerConfig;\n  const configMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);\n  return configMiddleware;\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey)]);\n}\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$3({}, req));\n    res.result = result;\n  });\n}\n\nconst getPhantomHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const transaction = await injectedProvider.signTransaction(txn);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"signMessage\",\n        params: {\n          message: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signAndSendTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const txRes = await injectedProvider.signAndSendTransaction(txn);\n      return {\n        signature: txRes.signature\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params2, _req$params3;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message) || !((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = req.params.message.map(msg => {\n        const decodedMsg = bs58.decode(msg);\n        return Transaction.from(decodedMsg);\n      });\n      const transaction = await injectedProvider.signAllTransactions(txns);\n      return transaction;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass PhantomInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$2(_objectSpread$2({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const providerHandlers = getPhantomHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const configMiddleware = createConfigMiddleware(this.config.chainConfig);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(configMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(injectedProvider);\n  }\n\n  async lookupNetwork(_) {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\"; // const genesisHash = await phantomProvider.request<string>({\n    //   method: \"getGenesisHash\",\n    //   params: [],\n    // });\n    // const { chainConfig } = this.config;\n    // if (!genesisHash) throw WalletInitializationError.rpcConnectionError(`Failed to connect with phantom wallet`);\n    // if (chainConfig.chainId !== genesisHash.substring(0, 32))\n    //   throw WalletInitializationError.invalidNetwork(\n    //     `Wallet is connected to wrong network,Please change your network to ${\n    //       SOLANA_NETWORKS[chainConfig.chainId] || chainConfig.displayName\n    //     } from phantom wallet extention.`\n    //   );\n    // return genesisHash.substring(0, 32);\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"sign_message\",\n        params: {\n          data: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"sign_transaction\",\n        params: {\n          message\n        }\n      });\n      const buf = Buffer.from(response, \"hex\");\n      const sendTx = Transaction.from(buf);\n      return sendTx;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"send_transaction\",\n        params: {\n          message\n        }\n      });\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const messages = [];\n\n      for (const transaction of req.params.message) {\n        const message = bs58.decode(transaction).toString(\"hex\");\n        messages.push(message);\n      }\n\n      const response = await injectedProvider.request({\n        method: \"sign_all_transactions\",\n        params: {\n          message: messages\n        }\n      });\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const transactionGenerator = serializedTx => {\n    const decodedTx = bs58.decode(serializedTx);\n    const tx = Transaction.from(decodedTx);\n    return tx;\n  };\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    signTransaction: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = transactionGenerator((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2.message);\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = transactionGenerator((_req$params5 = req.params) === null || _req$params5 === void 0 ? void 0 : _req$params5.message);\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params6, _req$params7;\n\n      if (!((_req$params6 = req.params) !== null && _req$params6 !== void 0 && _req$params6.message) || !((_req$params7 = req.params) !== null && _req$params7 !== void 0 && _req$params7.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedTransactions = [];\n\n      for (const tx of ((_req$params8 = req.params) === null || _req$params8 === void 0 ? void 0 : _req$params8.message) || []) {\n        var _req$params8;\n\n        const transaction = transactionGenerator(tx);\n        transaction.partialSign(keyPair);\n        signedTransactions.push(transaction);\n      }\n\n      return signedTransactions;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const messages = transactions.map(transaction => {\n      return bs58.encode(transaction.serialize({\n        requireAllSignatures: false\n      }));\n    });\n    const signedTransaction = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: messages\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, PrivateKeyWallet, SolanaPrivateKeyProvider, SolanaWallet, TorusInjectedProvider };\n//# sourceMappingURL=solanaProvider.esm.js.map\n",null,null,null,null,null,null,null,null,null,null],"sourceRoot":""}